# Pure YAML Itho ventilation control using ESPHome CC1101 component
# No external components needed!

# ===== CONFIGURATION =====
# Set your unique device ID here (array of 3 decimal numbers, 0-255)
# Each ESP/CC1101 must have a UNIQUE ID!
# Format: decimal integers (NOT hex!)
substitutions:
  device_id: "10, 87, 81"   # Device ID bytes (decimal 0-255 each)
  # Example: "10, 87, 81" displays as "0A,57,51" in hex
  # CHANGE THIS to make your device unique!
  
  # Controller name shown when controlling from Home Assistant
  controller_name: "Home Assistant"  # Change to your preferred name

esphome:
  name: itho-fan
  # Auto boot to LOW speed (ensures fan is at low speed at startup)
  on_boot:
    priority: -100  # Run after all components are initialized
    then:
      - delay: 2s  # Wait for components to be ready
      - lambda: |-
          ESP_LOGI("itho", "Boot: Setting fan to LOW speed");
          id(fan_speed) = 1;
          auto call = id(itho_ventilation).make_call();
          call.set_state(true);
          call.set_speed(1);
          call.perform();

esp8266:
  board: d1_mini
  framework:
    version: recommended

# Enable logging
logger:
  level: DEBUG

# Enable Home Assistant API
api:

ota:
  platform: esphome

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  min_auth_mode: WPA2  # Require WPA2 or better for security
  ap:
    ssid: "Itho Fan Fallback"
    password: "fallback123"

captive_portal:

# SPI configuration for CC1101
spi:
  clk_pin: D5   # GPIO14
  mosi_pin: D7  # GPIO13
  miso_pin: D6  # GPIO12

# CC1101 RF transceiver configuration
# Settings based on https://community.home-assistant.io/t/guide-controlling-itho-daalderop-fan-with-esp8266-and-cc1101/446808
cc1101:
  id: cc1101_transceiver
  cs_pin: D8        # GPIO15 on D1 Mini
  gdo0_pin: D1      # GPIO5
  
  # Base/carrier frequency: 868.299866MHz
  frequency: 868.2999MHz
  
  # 2-FSK modulation
  modulation_type: 2-FSK
  
  # Symbol rate: MDMCFG4=0x5A, MDMCFG3=0x83 = 38.3835 kBaud
  symbol_rate: 38383
  
  # Filter bandwidth: ~203kHz (based on MDMCFG4=0x5A)
  filter_bandwidth: 203kHz
  
  # Frequency deviation: DEVIATN=0x50 = 50.78125kHz
  fsk_deviation: 50kHz
  
  # Output power
  output_power: 10
  
  # Enable packet mode
  packet_mode: true
  
  # Packet mode configuration
  sync_mode: 16/16  # MDMCFG2=0x02 = 16-bit sync word
  sync1: 0xB3      # SYNC1=179 (0xB3)
  sync0: 0x2A      # SYNC0=42 (0x2A)
  packet_length: 63  # Fixed packet length (sync bytes removed by CC1101)
  crc_enable: false  # CRC disabled in ITHO
  whitening: false   # Data whitening disabled
  
  # Handle incoming packets
  on_packet:
    - lambda: |-
        ESP_LOGD("itho", "Received packet, RSSI: %.1f dBm, Size: %d", rssi, x.size());
        
        // ============================================================
        // HELPER FUNCTIONS (inline)
        // ============================================================
        
        // Helper: Log packet as hex string
        auto log_packet = [](const char* label, const std::vector<uint8_t>& data, int max_bytes = -1) {
          std::string hex = "";
          int count = (max_bytes < 0) ? data.size() : std::min((int)data.size(), max_bytes);
          for (int i = 0; i < count; i++) {
            char buf[4];
            sprintf(buf, "%02X ", data[i]);
            hex += buf;
          }
          ESP_LOGD("itho", "%s: %s", label, hex.c_str());
        };
        
        // Helper: Decode Itho custom Manchester-like encoding
        // 63 raw bytes → 24 decoded bytes (extracts even bits from 10-bit groups)
        auto decode_packet = [](const std::vector<uint8_t>& raw, uint8_t* decoded) -> bool {
          const int STARTBYTE = 2;  // Skip first 2 bytes after sync
          if (raw.size() < 10) {
            ESP_LOGW("itho", "Packet too short: %d bytes", raw.size());
            return false;
          }
          
          int out_byte = 0;
          int out_bit = 4;
          int in_bitcounter = 0;
          
          for (int i = STARTBYTE; i < raw.size() && out_byte < 24; i++) {
            for (int j = 7; j >= 0 && out_byte < 24; j--) {
              // Extract even bits (0, 2, 4, 6) from 10-bit groups
              if (in_bitcounter == 0 || in_bitcounter == 2 || in_bitcounter == 4 || in_bitcounter == 6) {
                uint8_t bit = (raw[i] >> j) & 0x01;
                decoded[out_byte] |= (bit << out_bit);
                out_bit--;
                
                if (out_bit < 0) {
                  out_byte++;
                  out_bit = 7;
                }
              }
              
              in_bitcounter++;
              if (in_bitcounter >= 10) {
                in_bitcounter = 0;
              }
            }
          }
          return true;
        };
        
        // Helper: Check if device ID is in whitelist
        auto check_whitelist = [](const char* device_id) -> const char* {
          struct RemoteID {
            const char* id;
            const char* room_name;
          };
          
          RemoteID allowed_remotes[] = {
            {"51,40,61", "Badkamer"},   // Remote 1 - decimal: 51,40,61 (hex: 0x33,0x28,0x3D)
            {"73,82,11", "Toilet"},     // Remote 2 - decimal: 73,82,11 (hex: 0x49,0x52,0x0B)
            {"10,87,81", "Keuken"}      // Remote 3 - decimal: 10,87,81 (hex: 0x0A,0x57,0x51)
            // CHANGE THESE TO YOUR ACTUAL REMOTE IDs!
          };
          
          for (auto& remote : allowed_remotes) {
            if (strcmp(device_id, remote.id) == 0) {
              return remote.room_name;
            }
          }
          return nullptr;  // Not in whitelist
        };
        
        // Helper: Parse command bytes and return speed/timer
        auto parse_command = [](const uint8_t* decoded, int& speed, int& timer) -> bool {
          // Command patterns (identical to ESPEASY plugin):
          // Low:    22 F1 03 00 02 04
          // Medium: 22 F1 03 00 03 04
          // High:   22 F1 03 00 04 04
          // Timer:  22 F3 03 00 00 0A/14/1E
          // JOIN:   1F C9 0C 00 1F C9
          // LEAVE:  1F C9 06 00 1F C9
          
          speed = -1;
          timer = 0;
          
          // Check for JOIN/LEAVE commands
          if (decoded[5] == 0x1F && decoded[6] == 0xC9 && decoded[9] == 0x1F && decoded[10] == 0xC9) {
            if (decoded[7] == 0x0C && decoded[8] == 0x00) {
              ESP_LOGI("itho", "Command: JOIN/PAIR");
              return false;  // Don't update fan state
            } else if (decoded[7] == 0x06 && decoded[8] == 0x00) {
              ESP_LOGI("itho", "Command: LEAVE/UNPAIR");
              return false;  // Don't update fan state
            }
          }
          
          // Check for speed/timer commands
          if (decoded[5] == 0x22 && decoded[7] == 0x03) {
            if (decoded[6] == 0xF1) {
              // Speed command
              switch (decoded[9]) {
                case 0x02: ESP_LOGI("itho", "Command: LOW speed"); speed = 1; break;
                case 0x03: ESP_LOGI("itho", "Command: MEDIUM speed"); speed = 2; break;
                case 0x04: ESP_LOGI("itho", "Command: HIGH speed"); speed = 3; break;
                default: ESP_LOGW("itho", "Unknown speed byte: 0x%02X", decoded[9]); break;
              }
            } else if (decoded[6] == 0xF3) {
              // Timer command
              switch (decoded[10]) {
                case 0x0A: ESP_LOGI("itho", "Command: TIMER 10min"); speed = 3; timer = 600; break;
                case 0x14: ESP_LOGI("itho", "Command: TIMER 20min"); speed = 3; timer = 1200; break;
                case 0x1E: ESP_LOGI("itho", "Command: TIMER 30min"); speed = 3; timer = 1800; break;
                default: ESP_LOGW("itho", "Unknown timer value: 0x%02X", decoded[10]); break;
              }
            }
          }
          
          return (speed > 0);
        };
        
        // Helper: Update fan entity
        auto update_fan = [](int speed, int timer, const char* source) {
          id(fan_speed) = speed;
          id(fan_timer) = timer;
          id(last_source) = std::string(source);
          
          // Set flag to prevent re-transmission
          id(updating_from_packet) = true;
          
          // Update fan entity
          auto call = id(itho_ventilation).make_call();
          call.set_state(true);
          call.set_speed(speed);
          
          // Set preset mode if timer is active
          if (timer == 600) {
            call.set_preset_mode("Timer 10min");
          } else if (timer == 1200) {
            call.set_preset_mode("Timer 20min");
          } else if (timer == 1800) {
            call.set_preset_mode("Timer 30min");
          } else {
            call.set_preset_mode("");
          }
          
          call.perform();
          
          // Clear flag after update
          id(updating_from_packet) = false;
          
          ESP_LOGI("itho", "Updated fan: speed=%d, timer=%ds, source=%s", speed, timer, source);
        };
        
        // ============================================================
        // MAIN PACKET PROCESSING
        // ============================================================
        
        // Log raw packet
        log_packet("Raw packet", x);
        
        // Decode packet using custom Itho encoding
        uint8_t decoded[24] = {0};
        if (!decode_packet(x, decoded)) {
          return;  // Decoding failed
        }
        
        // Log decoded packet
        std::vector<uint8_t> decoded_vec(decoded, decoded + 24);
        log_packet("Decoded packet", decoded_vec, 12);
        
        // Extract and check device ID (bytes 1-3)
        char device_id[16];
        sprintf(device_id, "%d,%d,%d", decoded[1], decoded[2], decoded[3]);
        ESP_LOGD("itho", "Device ID: %s (hex: %02X,%02X,%02X)", 
                 device_id, decoded[1], decoded[2], decoded[3]);
        
        const char* room_name = check_whitelist(device_id);
        if (!room_name) {
          ESP_LOGW("itho", "Ignored packet from unknown device: %s", device_id);
          return;
        }
        
        ESP_LOGI("itho", "Accepted command from: %s (%s)", room_name, device_id);
        
        // Parse command and update fan if needed
        int new_speed, new_timer;
        if (parse_command(decoded, new_speed, new_timer)) {
          update_fan(new_speed, new_timer, room_name);
        }

globals:
  - id: fan_speed
    type: int
    restore_value: no
    initial_value: '1'
  - id: fan_timer
    type: int
    restore_value: no
    initial_value: '0'
  - id: last_source
    type: std::string
    restore_value: no
    initial_value: '"System"'
  - id: updating_from_packet
    type: bool
    restore_value: no
    initial_value: 'false'
  # Rolling code counter for replay attack prevention
  - id: rollcode
    type: uint16_t
    restore_value: yes
    initial_value: '0'
  # Device ID bytes (configured via substitutions)
  - id: my_device_id
    type: uint8_t[3]
    restore_value: no
    initial_value: '{${device_id}}'

# Helper script for Itho custom encoding and transmission
# Encodes using custom "Manchester-like" encoding (NOT standard Manchester!)
# Based on ESPEasy IthoCC1101.cpp and RonaldHiemstra implementation
script:
  - id: itho_encode_and_send
    parameters:
      command_bytes: "std::vector<uint8_t>"
    then:
      - lambda: |-
          // Build decoded packet structure (24 bytes)
          uint8_t decoded[24] = {0};
          
          // Byte 0: Counter
          decoded[0] = id(rollcode) & 0xFF;
          
          // Bytes 1-3: Device ID
          decoded[1] = id(my_device_id)[0];
          decoded[2] = id(my_device_id)[1];
          decoded[3] = id(my_device_id)[2];
          
          // Byte 4: Counter (again, for some reason)
          decoded[4] = (id(rollcode) >> 8) & 0xFF;
          
          // Bytes 5-10: Command bytes (passed as parameter)
          for (int i = 0; i < command_bytes.size() && i < 6; i++) {
            decoded[5 + i] = command_bytes[i];
          }
          
          // Calculate checksum (bytes 11+)
          uint8_t checksum = 0;
          for (int i = 1; i < 11; i++) {
            checksum += decoded[i];
          }
          decoded[11] = (256 - checksum) & 0xFF;
          
          // Log decoded packet
          std::string hex_decoded = "";
          for (int i = 0; i < 12; i++) {
            char buf[4];
            sprintf(buf, "%02X ", decoded[i]);
            hex_decoded += buf;
          }
          ESP_LOGD("itho", "Decoded packet to encode: %s", hex_decoded.c_str());
          
          // Custom Itho encoding: 24 decoded bytes → 63 raw bytes
          // Inserts 1-0 pattern after every 8 data bits
          uint8_t encoded[63] = {0};
          int out_byte = 0;
          int out_bit = 7;
          int out_pattern_counter = 0;
          
          for (int byte_idx = 0; byte_idx < 12; byte_idx++) {
            for (int bit_idx = 7; bit_idx >= 0; bit_idx--) {
              // Check if we need to insert 1-0 pattern
              if (out_pattern_counter == 8) {
                out_pattern_counter = 0;
                // Insert 1
                encoded[out_byte] |= (1 << out_bit);
                out_bit--;
                if (out_bit < 0) {
                  out_byte++;
                  out_bit = 7;
                }
                // Insert 0
                encoded[out_byte] |= (0 << out_bit);
                out_bit--;
                if (out_bit < 0) {
                  out_byte++;
                  out_bit = 7;
                }
              }
              
              // Add data bit
              uint8_t bit = (decoded[byte_idx] >> bit_idx) & 0x01;
              encoded[out_byte] |= (bit << out_bit);
              out_bit--;
              if (out_bit < 0) {
                out_byte++;
                out_bit = 7;
              }
              out_pattern_counter++;
            }
          }
          
          // Add preamble (7 bytes of 0xAA at start)
          std::vector<uint8_t> packet;
          for (int i = 0; i < 7; i++) {
            packet.push_back(0xAA);
          }
          
          // Add encoded data
          for (int i = 0; i < out_byte; i++) {
            packet.push_back(encoded[i]);
          }
          
          // Add trailing pattern
          for (int i = 0; i < 7; i++) {
            packet.push_back(0xAA);
          }
          
          // Log encoded packet
          std::string hex_encoded = "";
          for (auto b : packet) {
            char buf[4];
            sprintf(buf, "%02X ", b);
            hex_encoded += buf;
          }
          ESP_LOGD("itho", "Encoded packet (%d bytes): %s", packet.size(), hex_encoded.c_str());
          
          // Increment rollcode for next transmission
          id(rollcode)++;
          
          // Transmit
          id(cc1101_transceiver).transmit_packet(packet);

# Template fan for control
fan:
  - platform: template
    id: itho_ventilation
    name: "Itho Ventilation"
    speed_count: 4
    preset_modes:
      - "Timer 10min"
      - "Timer 20min"
      - "Timer 30min"
    
    # Turn on/off
    on_turn_on:
      then:
        - lambda: |-
            // Don't retransmit if update came from received packet
            if (id(updating_from_packet)) {
              ESP_LOGD("itho", "Skipping transmit - update from received packet");
              return;
            }
            
            ESP_LOGI("itho", "Sending LOW command");
            id(fan_speed) = 1;
            id(last_source) = "${controller_name}";
            
            // LOW command: 22 F1 03 00 02 04
            std::vector<uint8_t> cmd = {0x22, 0xF1, 0x03, 0x00, 0x02, 0x04};
            id(itho_encode_and_send).execute(cmd);
    
    on_turn_off:
      then:
        - lambda: |-
            // Don't retransmit if update came from received packet
            if (id(updating_from_packet)) {
              ESP_LOGD("itho", "Skipping transmit - update from received packet");
              return;
            }
            
            ESP_LOGI("itho", "Sending LOW command (turn off)");
            id(fan_speed) = 1;
            id(last_source) = "${controller_name}";
            
            // LOW command: 22 F1 03 00 02 04
            std::vector<uint8_t> cmd = {0x22, 0xF1, 0x03, 0x00, 0x02, 0x04};
            id(itho_encode_and_send).execute(cmd);
    
    # Speed control
    on_speed_set:
      then:
        - lambda: |-
            // Don't retransmit if update came from received packet
            if (id(updating_from_packet)) {
              ESP_LOGD("itho", "Skipping transmit - update from received packet");
              return;
            }
            
            int speed = id(itho_ventilation).speed;
            std::vector<uint8_t> cmd;
            
            // Map speed to command bytes
            if (speed == 1) {
              // LOW: 22 F1 03 00 02 04
              cmd = {0x22, 0xF1, 0x03, 0x00, 0x02, 0x04};
            } else if (speed == 2) {
              // MEDIUM: 22 F1 03 00 03 04
              cmd = {0x22, 0xF1, 0x03, 0x00, 0x03, 0x04};
            } else if (speed == 3 || speed == 4) {
              // HIGH: 22 F1 03 00 04 04
              cmd = {0x22, 0xF1, 0x03, 0x00, 0x04, 0x04};
            } else {
              ESP_LOGW("itho", "Invalid speed: %d", speed);
              return;
            }
            
            ESP_LOGI("itho", "Sending speed %d command", speed);
            id(fan_speed) = speed;
            id(last_source) = "${controller_name}";
            
            id(itho_encode_and_send).execute(cmd);
    
    # Preset modes (timers)
    on_preset_set:
      then:
        - lambda: |-
            // Don't retransmit if update came from received packet
            if (id(updating_from_packet)) {
              ESP_LOGD("itho", "Skipping transmit - update from received packet");
              return;
            }
            
            std::string preset = id(itho_ventilation).get_preset_mode();
            std::vector<uint8_t> cmd;
            
            // Timer commands
            if (preset == "Timer 10min") {
              // Timer 10min: 22 F3 03 00 00 0A
              cmd = {0x22, 0xF3, 0x03, 0x00, 0x00, 0x0A};
              id(fan_timer) = 600;
            } else if (preset == "Timer 20min") {
              // Timer 20min: 22 F3 03 00 00 14
              cmd = {0x22, 0xF3, 0x03, 0x00, 0x00, 0x14};
              id(fan_timer) = 1200;
            } else if (preset == "Timer 30min") {
              // Timer 30min: 22 F3 03 00 00 1E
              cmd = {0x22, 0xF3, 0x03, 0x00, 0x00, 0x1E};
              id(fan_timer) = 1800;
            } else {
              ESP_LOGW("itho", "Unknown preset: %s", preset.c_str());
              return;
            }
            
            ESP_LOGI("itho", "Sending timer command: %s", preset.c_str());
            id(last_source) = "${controller_name}";
            
            id(itho_encode_and_send).execute(cmd);

# Text sensors for status
text_sensor:
  - platform: template
    name: "Fan Timer Remaining"
    id: timer_display
    icon: "mdi:timer"
    lambda: |-
      if (id(fan_timer) > 0) {
        int minutes = id(fan_timer) / 60;
        int seconds = id(fan_timer) % 60;
        char buffer[20];
        sprintf(buffer, "%d:%02d", minutes, seconds);
        return {buffer};
      }
      return {"Off"};
    update_interval: 1s
    
  - platform: template
    name: "Last Control Source"
    id: controller_name
    icon: "mdi:remote"
    lambda: |-
      return {id(last_source)};
  
  - platform: template
    name: "Rollcode Counter"
    id: rollcode_display
    icon: "mdi:counter"
    lambda: |-
      char buffer[10];
      sprintf(buffer, "%d", id(rollcode));
      return {buffer};
    update_interval: 60s

# Buttons to pair/unpair CC1101 with Itho ventilation unit
# IMPORTANT: Ventilation unit must be in pairing mode!
# Power OFF the unit, wait 10 sec, power ON - unit is in pairing mode for 30 sec
# 
# ⚠️ WARNING: These JOIN/LEAVE commands are experimental and may not work
# JOIN/LEAVE commands use identical encoding as ESPEASY plugin
# Command bytes verified against jodur/ESPEASY_Plugin_ITHO
button:
  - platform: template
    name: "Join/Pair CC1101 with Fan"
    id: join_button
    icon: "mdi:link-plus"
    on_press:
      - logger.log: "Sending JOIN command to pair with ventilation unit"
      - logger.log: "⚠️ Ventilation unit must be freshly powered on (within 2 minutes)!"
      - lambda: |-
          // Send JOIN command - uses same encoding as ESPEASY plugin
          // JOIN command: 0x1F 0xC9 0x0C 0x00 0x1F 0xC9
          // This is encoded and sent exactly like other commands (LOW/MEDIUM/HIGH)
          std::vector<uint8_t> cmd = {0x1F, 0xC9, 0x0C, 0x00, 0x1F, 0xC9};
          
          ESP_LOGI("itho", "Sending JOIN command - pairing with unit");
          id(itho_encode_and_send).execute(cmd);
      - delay: 2s
      - logger.log: "JOIN command sent - check if unit LED confirms pairing"

  - platform: template
    name: "Leave/Unpair CC1101 from Fan"
    id: leave_button
    icon: "mdi:link-off"
    on_press:
      - logger.log: "Sending LEAVE command to unpair from ventilation unit"
      - logger.log: "⚠️ Ventilation unit must be freshly powered on (within 2 minutes)!"
      - lambda: |-
          // Send LEAVE command - uses same encoding as ESPEASY plugin
          // LEAVE command: 0x1F 0xC9 0x06 0x00 0x1F 0xC9
          // This is encoded and sent exactly like other commands (LOW/MEDIUM/HIGH)
          std::vector<uint8_t> cmd = {0x1F, 0xC9, 0x06, 0x00, 0x1F, 0xC9};
          
          ESP_LOGI("itho", "Sending LEAVE command - unpairing from unit");
          id(itho_encode_and_send).execute(cmd);
      - delay: 2s
      - logger.log: "LEAVE command sent - device should be unpaired"

# Timer countdown (runs every second)
interval:
  - interval: 1s
    then:
      - lambda: |-
          if (id(fan_timer) > 0) {
            id(fan_timer)--;
            if (id(fan_timer) == 0) {
              // Timer expired, return to low speed and clear preset mode
              ESP_LOGD("itho", "Timer expired, returning to low speed");
              auto call = id(itho_ventilation).make_call();
              call.set_speed(1);
              call.set_preset_mode("");  // Clear preset mode
              call.perform();
            }
          }
